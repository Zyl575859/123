name: 构建Android APK

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: 安装系统依赖
      run: |
        sudo apt-get update
        sudo apt-get install -y git zip unzip openjdk-11-jdk python3-pip build-essential autoconf automake libtool libtool-bin pkg-config zlib1g-dev libncurses5-dev libncursesw5-dev cmake libffi-dev libssl-dev python3-dev
        
    - name: 安装Buildozer和所有依赖
      run: |
        pip3 install --user buildozer cython wheel setuptools
        pip3 install --user python-for-android
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: 初始化Android SDK环境
      run: |
        mkdir -p ~/.android
        touch ~/.android/repositories.cfg
        export ANDROID_HOME=$HOME/.buildozer/android/platform/android-sdk
        mkdir -p $ANDROID_HOME/licenses
        
    - name: 手动安装Android SDK Command-line Tools
      run: |
        export ANDROID_HOME=$HOME/.buildozer/android/platform/android-sdk
        mkdir -p $ANDROID_HOME/cmdline-tools
        cd /tmp
        wget -q https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip || wget -q https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
        unzip -q commandlinetools-linux-*.zip -d $ANDROID_HOME/cmdline-tools
        mv $ANDROID_HOME/cmdline-tools/cmdline-tools $ANDROID_HOME/cmdline-tools/latest || true
        mkdir -p $ANDROID_HOME/tools/bin
        if [ -f "$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager" ]; then
          ln -sf $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager $ANDROID_HOME/tools/bin/sdkmanager || true
        fi
        
    - name: 接受Android SDK许可证
      run: |
        export ANDROID_HOME=$HOME/.buildozer/android/platform/android-sdk
        export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
        mkdir -p $ANDROID_HOME/licenses
        echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" > $ANDROID_HOME/licenses/android-sdk-license
        echo "84831b9409646a918e30573bab4c9c91346d8abd" > $ANDROID_HOME/licenses/android-sdk-preview-license
        if [ -f "$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager" ]; then
          yes | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager --licenses || true
        fi
        
    - name: 设置Autotools环境变量
      run: |
        # 查找 libtool.m4 的实际位置
        LIBTOOL_M4=$(find /usr -name "libtool.m4" 2>/dev/null | head -1)
        if [ -n "$LIBTOOL_M4" ]; then
          LIBTOOL_DIR=$(dirname "$LIBTOOL_M4")
        else
          LIBTOOL_DIR="/usr/share/aclocal"
        fi
        
        # 构建 ACLOCAL_PATH
        ACLOCAL_PATHS="/usr/share/aclocal"
        if [ -d "/usr/share/libtool/config" ]; then
          ACLOCAL_PATHS="$ACLOCAL_PATHS:/usr/share/libtool/config"
        fi
        if [ -n "$LIBTOOL_DIR" ] && [ "$LIBTOOL_DIR" != "/usr/share/aclocal" ]; then
          ACLOCAL_PATHS="$ACLOCAL_PATHS:$LIBTOOL_DIR"
        fi
        for dir in /usr/share/automake-*; do
          if [ -d "$dir" ]; then
            ACLOCAL_PATHS="$ACLOCAL_PATHS:$dir"
          fi
        done
        
        # 使用 GITHUB_ENV 设置全局环境变量
        echo "ACLOCAL_PATH=$ACLOCAL_PATHS" >> $GITHUB_ENV
        echo "AUTOMAKE=automake" >> $GITHUB_ENV
        echo "AUTOCONF=autoconf" >> $GITHUB_ENV
        echo "M4PATH=$ACLOCAL_PATHS" >> $GITHUB_ENV
        
        echo "已设置全局环境变量:"
        echo "  ACLOCAL_PATH=$ACLOCAL_PATHS"
        
    - name: 创建autoreconf wrapper
      run: |
        mkdir -p ~/.local/bin
        echo '#!/bin/bash' > ~/.local/bin/autoreconf
        echo 'export ACLOCAL_PATH="${ACLOCAL_PATH:-/usr/share/aclocal:/usr/share/libtool/config}"' >> ~/.local/bin/autoreconf
        echo 'export AUTOMAKE="${AUTOMAKE:-automake}"' >> ~/.local/bin/autoreconf
        echo 'export AUTOCONF="${AUTOCONF:-autoconf}"' >> ~/.local/bin/autoreconf
        echo 'export M4PATH="${M4PATH:-$ACLOCAL_PATH}"' >> ~/.local/bin/autoreconf
        echo 'exec /usr/bin/autoreconf "$@"' >> ~/.local/bin/autoreconf
        chmod +x ~/.local/bin/autoreconf
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        echo "✅ autoreconf wrapper 已创建"
        
    - name: 构建APK
      run: |
        # 清理可能冲突的环境变量
        unset ANDROID_NDK_HOME || true
        unset ANDROID_NDK_ROOT || true
        unset ANDROID_NDK_LATEST_HOME || true
        
        # 设置正确的环境变量
        export ANDROID_HOME=$HOME/.buildozer/android/platform/android-sdk
        export ANDROID_NDK=$HOME/.buildozer/android/platform/android-ndk-r25b
        export ANDROID_SDK_ROOT=$ANDROID_HOME
        export PATH=$PATH:$ANDROID_HOME/tools/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/cmdline-tools/latest/bin
        export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/lib/pkgconfig
        export PYTHONPATH=$HOME/.local/lib/python3.10/site-packages:$PYTHONPATH
        
        # 确保 ACLOCAL_PATH 已设置（从 GITHUB_ENV 继承）
        if [ -z "$ACLOCAL_PATH" ]; then
          ACLOCAL_PATHS="/usr/share/aclocal"
          if [ -d "/usr/share/libtool/config" ]; then
            ACLOCAL_PATHS="$ACLOCAL_PATHS:/usr/share/libtool/config"
          fi
          export ACLOCAL_PATH=$ACLOCAL_PATHS
        fi
        export AUTOMAKE="${AUTOMAKE:-automake}"
        export AUTOCONF="${AUTOCONF:-autoconf}"
        export M4PATH="${M4PATH:-$ACLOCAL_PATH}"
        
        # 确保工作目录正确
        cd $GITHUB_WORKSPACE
        
        echo "=========================================="
        echo "开始构建 APK..."
        echo "=========================================="
        echo "环境变量:"
        echo "  ANDROID_HOME=$ANDROID_HOME"
        echo "  ANDROID_NDK=$ANDROID_NDK"
        echo "  ACLOCAL_PATH=$ACLOCAL_PATH"
        echo "  AUTOMAKE=$AUTOMAKE"
        echo "  AUTOCONF=$AUTOCONF"
        echo "  M4PATH=$M4PATH"
        echo "=========================================="
        echo ""
        
        # 运行构建，保存完整日志
        set -o pipefail
        buildozer -v android debug 2>&1 | tee build.log
        BUILD_EXIT_CODE=${PIPESTATUS[0]}
        
        echo ""
        echo "=========================================="
        echo "构建完成，退出代码: $BUILD_EXIT_CODE"
        echo "=========================================="
        
        if [ $BUILD_EXIT_CODE -ne 0 ]; then
          echo ""
          echo "=========================================="
          echo "构建失败！详细错误分析..."
          echo "=========================================="
          echo ""
          
          # 查找"命令失败"的位置，显示之前的错误
          FAILED_LINE=$(grep -n "命令失败\|command failed\|Buildozer 无法执行" build.log | tail -1 | cut -d: -f1)
          if [ -n "$FAILED_LINE" ]; then
            echo "找到'命令失败'在第 $FAILED_LINE 行"
            echo "显示该位置之前的 200 行（实际错误）："
            echo ""
            START_LINE=$((FAILED_LINE - 200))
            if [ $START_LINE -lt 1 ]; then
              START_LINE=1
            fi
            sed -n "${START_LINE},${FAILED_LINE}p" build.log
            echo ""
            echo "=========================================="
            echo ""
          fi
          
          echo "1. 查找 LT_SYS_SYMBOL_USCORE 相关错误："
          grep -i "LT_SYS_SYMBOL_USCORE\|可能未定义宏\|未定义宏" build.log | tail -30 || true
          echo ""
          echo "2. 查找 pythonforandroid.toolchain create 命令的完整输出："
          grep -A 50 -B 10 "pythonforandroid.toolchain create" build.log | tail -100 || true
          echo ""
          echo "3. 查找所有错误关键词（排除警告，最后 150 行）："
          grep -i "error\|failed\|失败\|错误\|exception\|traceback" build.log | grep -v "警告\|warning\|已过时\|deprecated\|autoupdate" | tail -150 || true
          echo ""
          echo "4. 查找 pythonforandroid 相关错误（最后 80 行）："
          grep -i "pythonforandroid\|toolchain\|p4a" build.log | tail -80 || true
          echo ""
          echo "5. 查找 Autotools 相关错误（非警告）："
          grep -i "autoreconf.*错误\|autoconf.*错误\|configure.*错误\|autotools.*错误" build.log | grep -v "警告\|warning" | tail -30 || true
          echo ""
          echo "6. 查找命令执行失败："
          grep -i "命令失败\|command failed\|无法执行\|cannot execute\|ErrorReturnCode" build.log | tail -20 || true
          echo ""
          echo "7. 查找 Traceback 完整信息："
          grep -A 30 -i "traceback" build.log | tail -80 || true
          echo ""
          echo "8. 构建日志最后 500 行（完整上下文）："
          tail -500 build.log
          echo ""
          echo "=========================================="
          
          # 保存完整日志
          mkdir -p logs
          cp build.log logs/build.log || true
          
          # 保存错误摘要（包含"命令失败"之前的错误）
          {
            echo "=== 错误摘要 ==="
            echo "构建退出代码: $BUILD_EXIT_CODE"
            echo ""
            echo "=== '命令失败'之前的错误（最后 200 行）==="
            if [ -n "$FAILED_LINE" ]; then
              START_LINE=$((FAILED_LINE - 200))
              if [ $START_LINE -lt 1 ]; then
                START_LINE=1
              fi
              sed -n "${START_LINE},${FAILED_LINE}p" build.log
            fi
            echo ""
            echo "=== LT_SYS_SYMBOL_USCORE 相关错误 ==="
            grep -i "LT_SYS_SYMBOL_USCORE\|可能未定义宏" build.log | tail -30
            echo ""
            echo "=== 所有错误关键词 ==="
            grep -i "error\|failed\|失败\|错误" build.log | grep -v "警告\|warning" | tail -150
            echo ""
            echo "=== 最后 500 行日志 ==="
            tail -500 build.log
          } > logs/error_summary.txt || true
          
          exit 1
        fi
        
        echo "✅ 构建成功完成！"
        
    - name: 查找APK文件
      run: |
        echo "=========================================="
        echo "查找APK文件..."
        echo "=========================================="
        echo "1. 检查 bin/ 目录："
        if [ -d "bin" ]; then
          ls -la bin/ || true
          find bin -name "*.apk" -type f 2>/dev/null || echo "bin/ 目录中没有找到 APK 文件"
        else
          echo "bin/ 目录不存在"
        fi
        echo ""
        echo "2. 检查 dist/ 目录："
        if [ -d "dist" ]; then
          ls -la dist/ || true
          find dist -name "*.apk" -type f 2>/dev/null || echo "dist/ 目录中没有找到 APK 文件"
        else
          echo "dist/ 目录不存在"
        fi
        echo ""
        echo "3. 在整个工作区查找所有 APK 文件："
        find . -name "*.apk" -type f 2>/dev/null | head -20 || echo "工作区中没有找到 APK 文件"
        echo "=========================================="
      
    - name: 复制APK到dist目录
      run: |
        echo "=========================================="
        echo "查找并复制 APK 文件到 dist/ 和 bin/ 目录"
        echo "=========================================="
        mkdir -p dist bin
        ALL_APK_FILES=$(find . -name "*.apk" -type f 2>/dev/null)
        if [ -n "$ALL_APK_FILES" ]; then
          echo "找到以下 APK 文件："
          echo "$ALL_APK_FILES"
          echo ""
          echo "复制所有 APK 文件..."
          for apk in $ALL_APK_FILES; do
            if [ -f "$apk" ]; then
              cp "$apk" dist/ && cp "$apk" bin/ && echo "✅ 复制: $apk" || echo "❌ 复制失败: $apk"
            fi
          done
        else
          echo "未找到任何 APK 文件"
        fi
        echo ""
        echo "检查 dist/ 和 bin/ 目录："
        ls -lah dist/ bin/ 2>/dev/null || true
        echo "=========================================="
      
    - name: 上传构建日志
      uses: actions/upload-artifact@v4
      if: failure()
      continue-on-error: true
      with:
        name: build-logs
        path: logs/*.log
        retention-days: 7
        if-no-files-found: ignore
      
    - name: 上传APK
      uses: actions/upload-artifact@v4
      if: always()
      continue-on-error: true
      with:
        name: android-apk
        path: |
          dist/*.apk
          bin/*.apk
        retention-days: 30
        if-no-files-found: warn
